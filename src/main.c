// !! this is just test code, and it is generated by AI.
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include "ekf/ekf.h"
#include "util.h"
#include "utils/utils.h"

// Simple Gaussian noise generator
float32_t gaussian_noise(float32_t std_dev) {
    float32_t u1 = (float32_t)rand() / RAND_MAX;
    float32_t u2 = (float32_t)rand() / RAND_MAX;
    return std_dev * sqrtf(-2.0f * logf(u1)) * cosf(2.0f * 3.14159f * u2);
}

int main() {
    uint16_t n = 2, m = 1; // State: [pos, vel], Measure: [pos]

    // 1. Memory Allocation
    float32_t x_b[2] = {0, 0};          // Initial: pos=0, vel=0
    float32_t p_b[4] = {1, 0, 0, 1};    // Initial uncertainty
    float32_t a_b[4] = {1, 1, 0, 1};    // A = [[1, dt], [0, 1]] where dt=1
    float32_t q_b[4] = {0.01f, 0, 0, 0.01f}; 
    float32_t r_b[1] = {1.0f};          // Measurement noise (Standard deviation = 1.0)
    
    // Workspace (2n^2 + 2nm + 2m^2 + mn) = 8 + 8 + 2 + 2 = 20
    float32_t w_b[EKF_WORK_SIZE(n, m)]; 

    EKF_Context ekf;
    EKF_Init(&ekf, n, m, w_b, x_b, p_b, a_b, q_b, r_b);

    char matName[] = "abc";
    print_matrix(matName, &ekf.A);

    // 2. Observation Matrix H = [[1, 0]] (We only measure position)
    float32_t h_data[2] = {1.0f, 0.0f};
    arm_matrix_instance_f32 H, z, u;
    arm_mat_init_f32(&H, 1, 2, h_data);
    arm_mat_init_f32(&u, 0, 0, NULL);

    // 3. Simulation & Logging
    float32_t true_pos = 0.0f;
    float32_t true_vel = 1.0f; // Constant velocity

    printf("step,true_pos,measure_pos,ekf_pos,ekf_vel\n");

    for (int i = 0; i < 50; i++) {
        // --- Physics: True State ---
        true_pos += true_vel; 

        // --- Sensor: Measure with Noise ---
        float32_t z_val = true_pos + gaussian_noise(10);
        arm_mat_init_f32(&z, 1, 1, &z_val);

        // --- EKF Steps ---
        EKF_Predict(&ekf, &u);
        EKF_Update(&ekf, &H, &z);

        // --- Output ---
        printf("%d,%.3f,%.3f,%.3f,%.3f\n", 
               i, true_pos, z_val, ekf.x.pData[0], ekf.x.pData[1]);
    }

    return 0;
}
